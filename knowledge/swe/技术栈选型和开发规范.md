# Zerocut 技术栈选型和开发规范

## 🎯 技术选型原则

### 选型标准

1. **成熟稳定**: 选择经过生产验证的成熟技术
2. **社区活跃**: 拥有活跃的开源社区和丰富的生态
3. **团队熟悉**: 团队具备相关技术经验或学习成本可控
4. **性能优先**: 满足高并发和低延迟要求
5. **可维护性**: 代码结构清晰，便于长期维护
6. **扩展性**: 支持业务快速增长和功能扩展

### 技术决策矩阵

| 技术领域 | 候选方案                 | 最终选择          | 选择理由                                |
| -------- | ------------------------ | ----------------- | --------------------------------------- |
| 前端框架 | React/Vue/Angular        | **Vue 3**         | 组合式API、响应式系统优秀、学习曲线平缓 |
| 状态管理 | Vuex/Pinia/Zustand       | **Pinia**         | Vue官方推荐、TypeScript友好、开发体验好 |
| 后端框架 | Express/Fastify/Koa      | **Express.js**    | 成熟稳定、中间件丰富、社区活跃          |
| 数据库   | PostgreSQL/MySQL/MongoDB | **PostgreSQL 17** | 功能强大、JSON支持、ACID特性            |
| ORM框架  | Prisma/TypeORM/Sequelize | **TypeORM**       | 装饰器语法、Active Record模式、功能完整 |
| 缓存方案 | Redis/Memcached          | **Redis 7.x**     | 功能丰富、数据结构多样、持久化          |

## 🛠️ 前端技术栈

### 核心技术栈

```json
{
  "framework": "Vue 3.4+",
  "language": "TypeScript 5.0+",
  "bundler": "Vite 5.0+",
  "styling": "TailwindCSS 3.4+",
  "stateManagement": "Pinia 2.1+",
  "routing": "Vue Router 4.2+",
  "httpClient": "Axios 1.6+",
  "dataFetching": "TanStack Query Vue 5.0+",
  "formHandling": "VeeValidate 4.11+",
  "validation": "Zod 3.22+",
  "charts": "Chart.js + Vue-Chartjs 5.3+",
  "icons": "Lucide Vue Next 0.300+",
  "testing": "Vitest + Vue Test Utils"
}
```

### 项目结构规范

```
src/
├── components/           # 可复用组件
│   ├── ui/              # 基础UI组件
│   │   ├── Button/
│   │   ├── Input/
│   │   ├── Modal/
│   │   └── index.ts
│   ├── business/        # 业务组件
│   │   ├── UserProfile/
│   │   ├── WorkspaceCard/
│   │   └── index.ts
│   └── layout/          # 布局组件
│       ├── Header/
│       ├── Sidebar/
│       └── index.ts
├── views/               # 页面组件
│   ├── auth/
│   │   ├── Login/
│   │   └── Register/
│   ├── dashboard/
│   └── workspace/
├── composables/         # 组合式函数
│   ├── useAuth.ts
│   ├── useWorkspace.ts
│   └── index.ts
├── stores/              # 状态管理
│   ├── auth.ts
│   ├── workspace.ts
│   └── index.ts
├── services/            # API服务
│   ├── api/
│   │   ├── auth.ts
│   │   ├── workspace.ts
│   │   └── index.ts
│   ├── http.ts          # HTTP客户端配置
│   └── types.ts         # API类型定义
├── utils/               # 工具函数
│   ├── format.ts
│   ├── validation.ts
│   └── constants.ts
├── types/               # 类型定义
│   ├── auth.ts
│   ├── workspace.ts
│   └── index.ts
├── styles/              # 样式文件
│   ├── globals.css
│   └── components.css
└── App.vue              # 应用入口
```

### 组件开发规范

#### 1. 组件命名规范

```vue
<!-- ✅ 正确：使用PascalCase文件名 UserProfile.vue -->
<template>
  <div>{{ user.name }}</div>
</template>

<script setup lang="ts">
interface Props {
  user: User;
}

defineProps<Props>();
</script>

<!-- ❌ 错误：使用camelCase文件名 userProfile.vue -->
```

#### 2. Props类型定义

```vue
<!-- ✅ 正确：明确的Props接口定义 -->
<template>
  <div :class="className">
    {{ user.name }}
    <button v-if="onEdit" @click="() => onEdit?.(user)">编辑</button>
    <slot></slot>
  </div>
</template>

<script setup lang="ts">
interface Props {
  user: User;
  onEdit?: (user: User) => void;
  className?: string;
}

defineProps<Props>();
</script>

<!-- ❌ 错误：使用any类型 -->
<script setup lang="ts">
defineProps<any>();
</script>
```

#### 3. 状态管理规范

```typescript
// ✅ 正确：使用Pinia进行状态管理
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';

export const useAuthStore = defineStore('auth', () => {
  const user = ref<User | null>(null);
  const token = ref<string | null>(null);
  const isLoading = ref(false);

  const isAuthenticated = computed(() => !!user.value && !!token.value);

  const login = async (email: string, password: string) => {
    isLoading.value = true;
    try {
      const response = await authApi.login({ email, password });
      user.value = response.user;
      token.value = response.token;
    } catch (error) {
      throw error;
    } finally {
      isLoading.value = false;
    }
  };

  const logout = () => {
    user.value = null;
    token.value = null;
  };

  return {
    user: readonly(user),
    token: readonly(token),
    isLoading: readonly(isLoading),
    isAuthenticated,
    login,
    logout,
  };
});
```

#### 4. 组合式函数规范

```typescript
// ✅ 正确：组合式函数命名以use开头
import { ref, computed, watch } from 'vue';
import { useQuery } from '@tanstack/vue-query';

export const useWorkspaceData = (workspaceId: Ref<string>) => {
  const { data, isLoading, error } = useQuery({
    queryKey: ['workspace', workspaceId],
    queryFn: () => workspaceApi.getById(workspaceId.value),
    enabled: computed(() => !!workspaceId.value)
  });

  return {
    workspace: computed(() => data.value),
    isLoading,
    error
  };
};

// 使用示例
// WorkspaceDetail.vue
<template>
  <div>
    <LoadingSpinner v-if="isLoading" />
    <ErrorMessage v-else-if="error" :error="error" />
    <div v-else>{{ workspace?.name }}</div>
  </div>
</template>

<script setup lang="ts">
interface Props {
  id: string;
}

const props = defineProps<Props>();
const workspaceId = toRef(props, 'id');
const { workspace, isLoading, error } = useWorkspaceData(workspaceId);
</script>
```

### CSS和样式规范

#### 1. TailwindCSS使用规范

```typescript
// ✅ 正确：使用Tailwind类名
const Button: React.FC<ButtonProps> = ({ variant, size, children }) => {
  const baseClasses = 'inline-flex items-center justify-center rounded-md font-medium transition-colors';

  const variantClasses = {
    primary: 'bg-blue-600 text-white hover:bg-blue-700',
    secondary: 'bg-gray-200 text-gray-900 hover:bg-gray-300',
    outline: 'border border-gray-300 bg-transparent hover:bg-gray-50'
  };

  const sizeClasses = {
    sm: 'h-8 px-3 text-sm',
    md: 'h-10 px-4 text-base',
    lg: 'h-12 px-6 text-lg'
  };

  return (
    <button
      className={cn(
        baseClasses,
        variantClasses[variant],
        sizeClasses[size]
      )}
    >
      {children}
    </button>
  );
};
```

#### 2. 响应式设计规范

```typescript
// ✅ 正确：移动优先的响应式设计
const Dashboard: React.FC = () => {
  return (
    <div className="
      grid
      grid-cols-1
      gap-4
      p-4
      sm:grid-cols-2
      sm:gap-6
      sm:p-6
      lg:grid-cols-3
      lg:gap-8
      lg:p-8
      xl:grid-cols-4
    ">
      {/* 卡片内容 */}
    </div>
  );
};
```

## 🔧 后端技术栈

### 核心技术栈

```json
{
  "runtime": "Node.js 20 LTS",
  "language": "TypeScript 5.0+",
  "framework": "Express.js 4.18+",
  "database": "PostgreSQL 17",
  "orm": "TypeORM 0.3.17+",
  "cache": "Redis 7.2+",
  "authentication": "JWT + bcrypt",
  "validation": "Joi 17.11+",
  "documentation": "Swagger/OpenAPI 3.0",
  "testing": "Jest + Supertest",
  "logging": "Winston 3.11+",
  "monitoring": "Prometheus + Grafana"
}
```

### 项目结构规范

```
src/
├── controllers/          # 控制器层
│   ├── auth.controller.ts
│   ├── workspace.controller.ts
│   └── index.ts
├── services/            # 业务逻辑层
│   ├── auth.service.ts
│   ├── workspace.service.ts
│   └── index.ts
├── repositories/        # 数据访问层
│   ├── user.repository.ts
│   ├── workspace.repository.ts
│   └── index.ts
├── middleware/          # 中间件
│   ├── auth.middleware.ts
│   ├── validation.middleware.ts
│   ├── error.middleware.ts
│   └── index.ts
├── routes/              # 路由定义
│   ├── auth.routes.ts
│   ├── workspace.routes.ts
│   └── index.ts
├── models/              # 数据模型
│   ├── user.model.ts
│   ├── workspace.model.ts
│   └── index.ts
├── types/               # 类型定义
│   ├── auth.types.ts
│   ├── workspace.types.ts
│   └── index.ts
├── utils/               # 工具函数
│   ├── jwt.util.ts
│   ├── password.util.ts
│   ├── validation.util.ts
│   └── index.ts
├── config/              # 配置文件
│   ├── database.config.ts
│   ├── redis.config.ts
│   └── index.ts
├── entities/            # TypeORM实体定义
│   ├── User.entity.ts
│   ├── Workspace.entity.ts
│   └── index.ts
├── migrations/          # TypeORM数据库迁移
│   └── *.ts
└── app.ts               # 应用入口
```

### API设计规范

#### 1. RESTful API规范

```typescript
// ✅ 正确：RESTful路由设计
const workspaceRoutes = {
  'GET /api/v1/workspaces': '获取工作空间列表',
  'POST /api/v1/workspaces': '创建工作空间',
  'GET /api/v1/workspaces/:id': '获取特定工作空间',
  'PUT /api/v1/workspaces/:id': '更新工作空间',
  'DELETE /api/v1/workspaces/:id': '删除工作空间',
  'POST /api/v1/workspaces/:id/members': '添加成员',
  'DELETE /api/v1/workspaces/:id/members/:userId': '移除成员',
};

// ❌ 错误：非RESTful设计
const badRoutes = {
  'POST /api/v1/getWorkspaces': '获取工作空间列表',
  'POST /api/v1/createWorkspace': '创建工作空间',
  'POST /api/v1/updateWorkspace': '更新工作空间',
};
```

#### 2. 统一响应格式

```typescript
// ✅ 正确：统一的API响应格式
interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  message?: string;
  error?: {
    code: string;
    message: string;
    details?: any;
  };
  pagination?: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}

// 成功响应
const successResponse = <T>(data: T, message?: string): ApiResponse<T> => ({
  success: true,
  data,
  message,
});

// 错误响应
const errorResponse = (code: string, message: string, details?: any): ApiResponse => ({
  success: false,
  error: { code, message, details },
});

// 使用示例
export const getWorkspaces = async (req: Request, res: Response) => {
  try {
    const workspaces = await workspaceService.getAll(req.user.id);
    res.json(successResponse(workspaces, '获取工作空间列表成功'));
  } catch (error) {
    res.status(500).json(errorResponse('INTERNAL_ERROR', '服务器内部错误'));
  }
};
```

#### 3. 输入验证规范

```typescript
// ✅ 正确：使用Joi进行输入验证
import Joi from 'joi';

const createWorkspaceSchema = Joi.object({
  name: Joi.string().min(1).max(100).required().messages({
    'string.empty': '工作空间名称不能为空',
    'string.max': '工作空间名称不能超过100个字符',
  }),
  description: Joi.string().max(500).optional(),
  isPublic: Joi.boolean().default(false),
});

export const validateCreateWorkspace = (req: Request, res: Response, next: NextFunction) => {
  const { error, value } = createWorkspaceSchema.validate(req.body);

  if (error) {
    return res.status(400).json(errorResponse('VALIDATION_ERROR', '输入验证失败', error.details));
  }

  req.body = value;
  next();
};
```

#### 4. 错误处理规范

```typescript
// ✅ 正确：统一错误处理
export class AppError extends Error {
  public readonly statusCode: number;
  public readonly code: string;
  public readonly isOperational: boolean;

  constructor(message: string, statusCode: number, code: string, isOperational = true) {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
    this.isOperational = isOperational;

    Error.captureStackTrace(this, this.constructor);
  }
}

// 预定义错误类型
export const ErrorTypes = {
  UNAUTHORIZED: (message = '未授权访问') => new AppError(message, 401, 'UNAUTHORIZED'),
  FORBIDDEN: (message = '禁止访问') => new AppError(message, 403, 'FORBIDDEN'),
  NOT_FOUND: (message = '资源不存在') => new AppError(message, 404, 'NOT_FOUND'),
  VALIDATION_ERROR: (message = '输入验证失败') => new AppError(message, 400, 'VALIDATION_ERROR'),
  INTERNAL_ERROR: (message = '服务器内部错误') => new AppError(message, 500, 'INTERNAL_ERROR'),
};

// 全局错误处理中间件
export const errorHandler = (err: Error, req: Request, res: Response, next: NextFunction) => {
  if (err instanceof AppError) {
    return res.status(err.statusCode).json(errorResponse(err.code, err.message));
  }

  // 未知错误
  logger.error('Unexpected error:', err);
  res.status(500).json(errorResponse('INTERNAL_ERROR', '服务器内部错误'));
};
```

### 数据库设计规范

#### 1. TypeORM Entity规范

```typescript
// ✅ 正确：清晰的TypeORM实体定义
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn, OneToMany } from 'typeorm';
import { UserWorkspace } from './UserWorkspace';
import { LoginSession } from './LoginSession';

export enum UserStatus {
  ACTIVE = 'ACTIVE',
  INACTIVE = 'INACTIVE',
  SUSPENDED = 'SUSPENDED',
}

@Entity('USER', { schema: 'user_management' })
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ type: 'varchar', length: 255, unique: true })
  email: string;

  @Column({ name: 'password_hash', type: 'varchar', length: 255 })
  passwordHash: string;

  @Column({ type: 'varchar', length: 100 })
  username: string;

  @Column({ type: 'varchar', length: 20, nullable: true })
  phone: string;

  @Column({ name: 'avatar_url', type: 'text', nullable: true })
  avatarUrl: string;

  @Column({ name: 'email_verified', type: 'boolean', default: false })
  emailVerified: boolean;

  @Column({ name: 'phone_verified', type: 'boolean', default: false })
  phoneVerified: boolean;

  @Column({ type: 'enum', enum: UserStatus, default: UserStatus.ACTIVE })
  status: UserStatus;

  @Column({ name: 'last_login_at', type: 'timestamptz', nullable: true })
  lastLoginAt: Date;

  @Column({ name: 'login_attempts', type: 'int', default: 0 })
  loginAttempts: number;

  @Column({ name: 'locked_until', type: 'timestamptz', nullable: true })
  lockedUntil: Date;

  @CreateDateColumn({ name: 'created_at', type: 'timestamptz' })
  createdAt: Date;

  @UpdateDateColumn({ name: 'updated_at', type: 'timestamptz' })
  updatedAt: Date;

  // 关联关系
  @OneToMany(() => UserWorkspace, userWorkspace => userWorkspace.user)
  userWorkspaces: UserWorkspace[];

  @OneToMany(() => LoginSession, loginSession => loginSession.user)
  loginSessions: LoginSession[];
}
```

#### 2. 数据访问层规范

```typescript
// ✅ 正确：Repository模式
import { Repository, DataSource } from 'typeorm';
import { Injectable } from '@nestjs/common';
import { User } from '../entities/User';
import { CreateUserData, UpdateUserData } from '../types/user.types';

@Injectable()
export class UserRepository {
  private repository: Repository<User>;

  constructor(private dataSource: DataSource) {
    this.repository = this.dataSource.getRepository(User);
  }

  async findById(id: number): Promise<User | null> {
    return this.repository.findOne({
      where: { id },
      relations: {
        userWorkspaces: {
          workspace: true,
        },
      },
    });
  }

  async findByEmail(email: string): Promise<User | null> {
    return this.repository.findOne({
      where: { email: email.toLowerCase() },
    });
  }

  async create(data: CreateUserData): Promise<User> {
    const user = this.repository.create({
      ...data,
      email: data.email.toLowerCase(),
    });
    return this.repository.save(user);
  }

  async update(id: number, data: UpdateUserData): Promise<User | null> {
    await this.repository.update(id, data);
    return this.findById(id);
  }

  async delete(id: number): Promise<void> {
    await this.repository.delete(id);
  }

  async findWithRelations(id: number): Promise<User | null> {
    return this.repository.findOne({
      where: { id },
      relations: ['userWorkspaces', 'loginSessions'],
    });
  }
}
```

## 🧪 测试规范

### 前端测试规范

#### 1. 组件测试

```typescript
// ✅ 正确：Vue组件测试
import { mount } from '@vue/test-utils';
import { vi } from 'vitest';
import Button from './Button.vue';

describe('Button Component', () => {
  it('should render with correct text', () => {
    const wrapper = mount(Button, {
      slots: {
        default: 'Click me',
      },
    });
    expect(wrapper.text()).toContain('Click me');
  });

  it('should call onClick when clicked', async () => {
    const handleClick = vi.fn();
    const wrapper = mount(Button, {
      props: {
        onClick: handleClick,
      },
      slots: {
        default: 'Click me',
      },
    });

    await wrapper.find('button').trigger('click');

    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('should be disabled when loading', () => {
    const wrapper = mount(Button, {
      props: {
        loading: true,
      },
      slots: {
        default: 'Click me',
      },
    });
    expect(wrapper.find('button').attributes('disabled')).toBeDefined();
  });
});
```

#### 2. 组合式函数测试

```typescript
// ✅ 正确：自定义组合式函数测试
import { vi } from 'vitest';
import { createPinia, setActivePinia } from 'pinia';
import { useAuth } from './useAuth';
import { authApi } from '../services/api';

// Mock API
vi.mock('../services/api', () => ({
  authApi: {
    login: vi.fn(),
  },
}));

describe('useAuth Composable', () => {
  beforeEach(() => {
    setActivePinia(createPinia());
  });

  it('should login successfully', async () => {
    const mockLogin = vi.mocked(authApi.login);
    mockLogin.mockResolvedValue({
      user: { id: 1, email: 'test@example.com' },
      token: 'mock-token',
    });

    const { login, user, isAuthenticated } = useAuth();

    await login('test@example.com', 'password');

    expect(user.value).toEqual({
      id: 1,
      email: 'test@example.com',
    });
    expect(isAuthenticated.value).toBe(true);
  });
});
```

### 后端测试规范

#### 1. 单元测试

```typescript
// ✅ 正确：服务层单元测试
import { AuthService } from '../services/auth.service';
import { UserRepository } from '../repositories/user.repository';
import { ErrorTypes } from '../utils/errors';

// Mock dependencies
jest.mock('../repositories/user.repository');
jest.mock('../utils/password.util');

describe('AuthService', () => {
  let authService: AuthService;
  let mockUserRepository: jest.Mocked<UserRepository>;

  beforeEach(() => {
    mockUserRepository = new UserRepository() as jest.Mocked<UserRepository>;
    authService = new AuthService(mockUserRepository);
  });

  describe('login', () => {
    it('should login successfully with valid credentials', async () => {
      const mockUser = {
        id: 1,
        email: 'test@example.com',
        passwordHash: 'hashed-password',
      };

      mockUserRepository.findByEmail.mockResolvedValue(mockUser);
      (passwordUtil.compare as jest.Mock).mockResolvedValue(true);

      const result = await authService.login('test@example.com', 'password');

      expect(result).toEqual({
        user: expect.objectContaining({ id: 1, email: 'test@example.com' }),
        token: expect.any(String),
      });
    });

    it('should throw error for invalid credentials', async () => {
      mockUserRepository.findByEmail.mockResolvedValue(null);

      await expect(authService.login('test@example.com', 'wrong-password')).rejects.toThrow(
        ErrorTypes.UNAUTHORIZED('邮箱或密码错误')
      );
    });
  });
});
```

#### 2. 集成测试

```typescript
// ✅ 正确：API集成测试
import request from 'supertest';
import { app } from '../app';
import { prisma } from '../config/database';

describe('Auth API', () => {
  beforeEach(async () => {
    // 清理测试数据
    await dataSource.getRepository(User).clear();
  });

  afterAll(async () => {
    await dataSource.destroy();
  });

  describe('POST /api/v1/auth/register', () => {
    it('should register a new user successfully', async () => {
      const userData = {
        email: 'test@example.com',
        password: 'Password123!',
        username: 'testuser',
      };

      const response = await request(app).post('/api/v1/auth/register').send(userData).expect(201);

      expect(response.body).toEqual({
        success: true,
        data: {
          user: expect.objectContaining({
            email: 'test@example.com',
            username: 'testuser',
          }),
          token: expect.any(String),
        },
        message: '注册成功',
      });
    });

    it('should return error for duplicate email', async () => {
      // 先创建一个用户
      const userRepo = dataSource.getRepository(User);
      await userRepo.save({
        email: 'test@example.com',
        passwordHash: 'hashed',
        username: 'existing',
      });

      const response = await request(app)
        .post('/api/v1/auth/register')
        .send({
          email: 'test@example.com',
          password: 'Password123!',
          username: 'newuser',
        })
        .expect(400);

      expect(response.body.success).toBe(false);
      expect(response.body.error.code).toBe('EMAIL_EXISTS');
    });
  });
});
```

## 📝 代码规范

### 通用规范

#### 1. 命名规范

```typescript
// ✅ 正确的命名
const MAX_RETRY_COUNT = 3; // 常量：SCREAMING_SNAKE_CASE
const userName = 'john'; // 变量：camelCase
const UserProfile = () => {}; // 组件：PascalCase
const getUserById = () => {}; // 函数：camelCase
interface UserData {} // 接口：PascalCase
type ApiResponse<T> = {}; // 类型：PascalCase
enum UserStatus {} // 枚举：PascalCase

// ❌ 错误的命名
const max_retry_count = 3; // 应该使用SCREAMING_SNAKE_CASE
const UserName = 'john'; // 应该使用camelCase
const userProfile = () => {}; // 组件应该使用PascalCase
const GetUserById = () => {}; // 函数应该使用camelCase
```

#### 2. 注释规范

```typescript
/**
 * 用户认证服务
 * 提供用户登录、注册、密码重置等功能
 */
export class AuthService {
  /**
   * 用户登录
   * @param email 用户邮箱
   * @param password 用户密码
   * @returns 包含用户信息和JWT令牌的对象
   * @throws {AppError} 当邮箱或密码错误时抛出UNAUTHORIZED错误
   */
  async login(email: string, password: string): Promise<LoginResult> {
    // 验证邮箱格式
    if (!this.isValidEmail(email)) {
      throw ErrorTypes.VALIDATION_ERROR('邮箱格式不正确');
    }

    // 查找用户
    const user = await this.userRepository.findByEmail(email);
    if (!user) {
      throw ErrorTypes.UNAUTHORIZED('邮箱或密码错误');
    }

    // TODO: 添加登录失败次数限制
    // FIXME: 密码比较逻辑需要优化性能

    return { user, token };
  }
}
```

#### 3. 导入导出规范

```typescript
// ✅ 正确：清晰的导入顺序
// 1. Node.js内置模块
import { readFileSync } from 'fs';
import { join } from 'path';

// 2. 第三方库
import express from 'express';
import { DataSource } from 'typeorm';
import bcrypt from 'bcrypt';

// 3. 项目内部模块（按层级排序）
import { AuthService } from '../services/auth.service';
import { UserRepository } from '../repositories/user.repository';
import { validateLogin } from '../middleware/validation.middleware';
import { ErrorTypes } from '../utils/errors';
import type { LoginRequest, LoginResponse } from '../types/auth.types';

// ✅ 正确：明确的导出
export { AuthController } from './auth.controller';
export { WorkspaceController } from './workspace.controller';
export type { ControllerResponse } from './types';

// ❌ 错误：混乱的导入顺序
import { AuthService } from '../services/auth.service';
import express from 'express';
import { validateLogin } from '../middleware/validation.middleware';
import { readFileSync } from 'fs';
```

### TypeScript规范

#### 1. 类型定义规范

```typescript
// ✅ 正确：明确的类型定义
interface User {
  readonly id: number;
  email: string;
  username: string;
  createdAt: Date;
  updatedAt: Date;
}

interface CreateUserRequest {
  email: string;
  password: string;
  username: string;
}

interface UpdateUserRequest {
  username?: string;
  email?: string;
}

type UserStatus = 'active' | 'inactive' | 'suspended';

// 泛型类型
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  message?: string;
  error?: ApiError;
}

// 工具类型的使用
type UserPublicInfo = Pick<User, 'id' | 'email' | 'username'>;
type UserUpdateData = Partial<Pick<User, 'email' | 'username'>>;

// ❌ 错误：使用any类型
interface BadUser {
  id: any;
  data: any;
  metadata: any;
}
```

#### 2. 函数类型规范

```typescript
// ✅ 正确：明确的函数类型
type EventHandler<T> = (event: T) => void;
type AsyncOperation<T, R> = (input: T) => Promise<R>;
type Validator<T> = (value: T) => boolean;

// 函数重载
function formatDate(date: Date): string;
function formatDate(date: string): string;
function formatDate(date: Date | string): string {
  const d = typeof date === 'string' ? new Date(date) : date;
  return d.toISOString().split('T')[0];
}

// 条件类型
type NonNullable<T> = T extends null | undefined ? never : T;
type ApiResult<T> = T extends string ? { message: T } : { data: T };
```

## 🔧 开发工具配置

### ESLint配置

```json
{
  "extends": ["@typescript-eslint/recommended", "@typescript-eslint/recommended-requiring-type-checking", "prettier"],
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "ecmaVersion": 2022,
    "sourceType": "module",
    "project": "./tsconfig.json"
  },
  "plugins": ["@typescript-eslint", "import"],
  "rules": {
    "@typescript-eslint/no-unused-vars": "error",
    "@typescript-eslint/no-explicit-any": "warn",
    "@typescript-eslint/explicit-function-return-type": "warn",
    "@typescript-eslint/no-non-null-assertion": "error",
    "import/order": [
      "error",
      {
        "groups": ["builtin", "external", "internal", "parent", "sibling", "index"],
        "newlines-between": "always"
      }
    ],
    "prefer-const": "error",
    "no-var": "error",
    "no-console": "warn"
  }
}
```

### Prettier配置

```json
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2,
  "useTabs": false,
  "bracketSpacing": true,
  "arrowParens": "avoid",
  "endOfLine": "lf"
}
```

### Git Hooks配置

```json
{
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged",
      "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"
    }
  },
  "lint-staged": {
    "*.{ts,tsx,js,jsx}": ["eslint --fix", "prettier --write", "git add"],
    "*.{json,md,yml,yaml}": ["prettier --write", "git add"]
  }
}
```

### 提交信息规范

```bash
# 提交信息格式
<type>(<scope>): <subject>

<body>

<footer>

# 类型说明
feat:     新功能
fix:      修复bug
docs:     文档更新
style:    代码格式调整
refactor: 代码重构
perf:     性能优化
test:     测试相关
chore:    构建工具或辅助工具的变动

# 示例
feat(auth): add user registration functionality

- Add user registration API endpoint
- Implement email validation
- Add password strength requirements
- Update user model with new fields

Closes #123
```

## 📚 文档规范

### API文档规范

```typescript
/**
 * @swagger
 * /api/v1/auth/login:
 *   post:
 *     summary: 用户登录
 *     tags: [Authentication]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *               - password
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *                 description: 用户邮箱
 *                 example: user@example.com
 *               password:
 *                 type: string
 *                 minLength: 8
 *                 description: 用户密码
 *                 example: Password123!
 *     responses:
 *       200:
 *         description: 登录成功
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 data:
 *                   type: object
 *                   properties:
 *                     user:
 *                       $ref: '#/components/schemas/User'
 *                     token:
 *                       type: string
 *                       description: JWT访问令牌
 *                 message:
 *                   type: string
 *                   example: 登录成功
 *       401:
 *         description: 认证失败
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 */
export const login = async (req: Request, res: Response) => {
  // 实现逻辑
};
```

### README文档模板

````markdown
# Zerocut 视频Agent管理平台

## 📖 项目简介

简要描述项目的目的、功能和特点。

## 🚀 快速开始

### 环境要求

- Node.js 20+
- PostgreSQL 17+
- Redis 7+
- Docker (可选)

### 安装步骤

1. 克隆项目

```bash
git clone <repository-url>
cd zerocut-platform
```
````

2. 安装依赖

```bash
npm install
```

3. 环境配置

```bash
cp .env.example .env
# 编辑 .env 文件，配置数据库连接等信息
```

4. 数据库初始化

```bash
npm run db:migrate
npm run db:seed
```

5. 启动开发服务器

```bash
npm run dev
```

## 📁 项目结构

```
project/
├── frontend/          # 前端代码
├── backend/           # 后端代码
├── docs/              # 项目文档
├── docker/            # Docker配置
└── scripts/           # 构建脚本
```

## 🛠️ 开发指南

### 代码规范

- 遵循 ESLint 和 Prettier 配置
- 使用 TypeScript 进行类型检查
- 编写单元测试和集成测试

### 提交规范

使用 Conventional Commits 规范：

```
feat(scope): add new feature
fix(scope): fix bug
docs(scope): update documentation
```

## 📊 API文档

开发环境API文档地址：http://localhost:3000/api-docs

## 🧪 测试

```bash
# 运行所有测试
npm test

# 运行测试并生成覆盖率报告
npm run test:coverage

# 运行端到端测试
npm run test:e2e
```

## 🚀 部署

### Docker部署

```bash
docker-compose up -d
```

### 手动部署

```bash
npm run build
npm run start:prod
```

## 📄 许可证

MIT License

```

## 🎯 总结

本技术栈选型和开发规范文档涵盖了：

1. **技术选型原则**：基于成熟度、性能、团队熟悉度等因素
2. **前端技术栈**：React + TypeScript + TailwindCSS + Zustand
3. **后端技术栈**：Node.js + Express + PostgreSQL + TypeORM
4. **代码规范**：命名、注释、导入导出、类型定义等
5. **测试规范**：单元测试、集成测试、端到端测试
6. **开发工具**：ESLint、Prettier、Git Hooks配置
7. **文档规范**：API文档、README文档模板

通过遵循这些规范，可以确保：
- 代码质量和一致性
- 团队协作效率
- 项目可维护性
- 开发体验优化
- 长期技术债务控制

建议在项目开始前，团队成员共同学习和确认这些规范，并在开发过程中严格执行。
```
